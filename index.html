<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>✨2026 烟花盛宴✨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
    <style>
        body { 
            margin: 0; 
            /* 【优化1：星空背景】使用CSS径向渐变模拟深邃夜空，并增加星星 */
            background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
            overflow: hidden; 
            touch-action: none; 
            height: 100vh;
        }
        /* 动态生成的星星层 */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(1px 1px at 20px 30px, #fff, rgba(0,0,0,0)),
                radial-gradient(1.5px 1.5px at 100px 150px, #fff, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 250px 50px, #ddd, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 150px 300px, #fff, rgba(0,0,0,0));
            background-size: 300px 400px;
            opacity: 0.4;
        }
        canvas { display: block; background: transparent; }
        #overlay {
            position: absolute; bottom: 5%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-family: "PingFang SC", sans-serif; 
            font-size: 13px; pointer-events: none; letter-spacing: 3px; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="overlay">点点屏幕 · 遇见美好</div>
    <canvas id="c"></canvas>

    <script>
    const canvas = document.getElementById('c');
    // 使用 alpha: true 允许背景透明
    const ctx = canvas.getContext('2d', { alpha: true });
    let cw, ch, particles = [], rockets = [];
    
    // 【优化2：文字序列】固定三次发射
    const autoTextList = [
        { text: "2026", pos: 0.25 },
        { text: "谢伊菲", pos: 0.50 },
        { text: "新年快乐", pos: 0.75 },
    ];
    let autoTextIdx = 0;
    let isAutoFinished = false;

    function init() {
        // 处理高分屏模糊问题
        const dpr = window.devicePixelRatio || 1;
        cw = canvas.width = window.innerWidth;
        ch = canvas.height = window.innerHeight;
    }

    function getPixels(text, yPosPercent) {
        const tCanvas = document.createElement('canvas');
        const tCtx = tCanvas.getContext('2d');
        tCanvas.width = cw; tCanvas.height = ch;
        
        // 【优化3：手机端适配字号】
        let fontSize;
        if (cw < 500) { // 手机端
            fontSize = text.length > 3 ? cw * 0.18 : cw * 0.25;
        } else { // PC端
            fontSize = text.length > 3 ? cw * 0.12 : cw * 0.18;
        }
        
        tCtx.font = `bold ${fontSize}px "PingFang SC", "Microsoft YaHei", sans-serif`;
        tCtx.textAlign = "center";
        tCtx.textBaseline = "middle";
        tCtx.fillStyle = "#fff";
        tCtx.fillText(text, cw/2, ch * yPosPercent);
        
        const data = tCtx.getImageData(0, 0, cw, ch).data;
        const pts = [];
        const step = cw < 500 ? 4 : 6; // 手机端采样加密，文字更细腻
        for (let y = 0; y < ch; y += step) {
            for (let x = 0; x < cw; x += step) {
                if (data[((y * cw + x) * 4) + 3] > 128) pts.push({x, y});
            }
        }
        return pts;
    }

    class Rocket {
        constructor(isAuto = false) {
            this.isAuto = isAuto;
            this.x = cw / 2 + random(-50, 50); // 从底部中间附近发射
            this.y = ch;
            
            if (isAuto) {
                this.tx = cw / 2;
                this.ty = ch * autoTextList[autoTextIdx].pos;
            } else {
                // 回复你原始的逻辑：随机位置爆炸
                this.tx = random(cw * 0.1, cw * 0.9);
                this.ty = random(ch * 0.1, ch * 0.5);
            }
            
            this.hue = random(0, 360);
            this.v = random(12, 16);
            this.done = false;
        }

        update() {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 10) {
                this.explode();
                this.done = true;
            } else {
                this.x += (dx/dist) * this.v;
                this.y += (dy/dist) * this.v;
            }
        }

        draw() {
            ctx.fillStyle = `hsla(${this.hue}, 100%, 75%, 1)`;
            ctx.fillRect(this.x, this.y, 2, 4);
        }

        explode() {
            if (this.isAuto) {
                const item = autoTextList[autoTextIdx];
                const pts = getPixels(item.text, item.pos);
                // 自动烟花设为金粉色
                pts.forEach(p => particles.push(new Particle(this.x, this.y, 40, p)));
                autoTextIdx++;
                if (autoTextIdx >= autoTextList.length) isAutoFinished = true;
            } else {
                const style = Math.floor(random(0, 4));
                const count = cw < 500 ? 120 : 200; // 手机端稍微减少粒子数防卡顿
                const baseHue = random(0, 360);
                for(let i=0; i<count; i++) {
                    const h = (baseHue + random(0, 30)) % 360;
                    if (style === 0) {
                        particles.push(new Particle(this.x, this.y, h, null, { speed: random(1, 10), gravity: 0.04 }));
                    } else if (style === 1) {
                        particles.push(new Particle(this.x, this.y, h, null, { speed: random(2, 12), isStrobe: true }));
                    } else if (style === 2) {
                        particles.push(new Particle(this.x, this.y, h, null, { speed: i < 50 ? 3 : 10 }));
                    } else {
                        const angle = (i / count) * Math.PI * 20;
                        const s = random(2, 10);
                        particles.push(new Particle(this.x, this.y, 45, null, { vx: Math.cos(angle)*s, vy: Math.sin(angle)*s }));
                    }
                }
            }
        }
    }

    class Particle {
        constructor(x, y, h, target = null, opt = {}) {
            this.x = x; this.y = y; this.h = h;
            this.target = target;
            this.alpha = 1;
            this.isSettled = false; // 是否已定格
            
            this.decay = target ? 0 : (opt.decay || random(0.008, 0.015)); 
            this.isStrobe = opt.isStrobe || false;
            this.gravity = opt.gravity || 0.06;
            this.friction = opt.friction || 0.96;
            
            if (opt.vx !== undefined) {
                this.vx = opt.vx; this.vy = opt.vy;
            } else {
                const angle = Math.random() * Math.PI * 2;
                const speed = target ? random(2, 8) : (opt.speed || random(2, 10));
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }
        }

        update() {
            if (this.isSettled) return; // 定格后不再计算

            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                this.vx += dx * 0.002;
                this.vy += dy * 0.002;
                this.vx *= 0.92; this.vy *= 0.92;
                
                // 接近目标位置时定格
                if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                    this.isSettled = true;
                    this.x = this.target.x;
                    this.y = this.target.y;
                }
            } else {
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.alpha -= this.decay;
            }
            this.x += this.vx;
            this.y += this.vy;
        }

        draw() {
            if (this.alpha <= 0) return;
            if (this.isStrobe && Math.random() > 0.6) return; 

            const s = this.target ? 1.8 : random(1, 3);
            // 文字粒子定格后保持微弱闪烁感，更有呼吸感
            const a = this.isSettled ? (0.8 + Math.random() * 0.2) : this.alpha;
            
            ctx.fillStyle = `hsla(${this.h}, 100%, ${this.target?85:75}%, ${a})`;
            ctx.fillRect(this.x, this.y, s, s);
        }
    }

    function loop() {
        // 【优化4：关键修改】使用 destination-out 产生半透明擦除效果，从而露出 CSS 背景
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.18)'; 
        ctx.fillRect(0, 0, cw, ch);
        
        ctx.globalCompositeOperation = 'lighter';

        rockets.forEach((r, i) => {
            r.update(); r.draw();
            if (r.done) rockets.splice(i, 1);
        });

        particles.forEach((p, i) => {
            p.update(); p.draw();
            // 只移除普通烟花粒子，文字粒子(target)由于decay为0且定格，会一直保留
            if (!p.target && p.alpha <= 0) particles.splice(i, 1);
        });
        
        requestAnimationFrame(loop);
    }

    function random(min, max) { return Math.random() * (max - min) + min; }

    function manualLaunch() {
        rockets.push(new Rocket(false));
    }

    window.addEventListener('touchstart', e => { e.preventDefault(); manualLaunch(); }, { passive: false });
    window.addEventListener('mousedown', manualLaunch);
    window.addEventListener('resize', init);

    init();
    loop();

    // 【优化5：自动播放逻辑】按顺序发射3次，然后停止发射器
    let autoTimer = setInterval(() => {
        if (isAutoFinished) {
            clearInterval(autoTimer);
            return;
        }
        rockets.push(new Rocket(true));
    }, 4000); 

    // 首发延迟
    setTimeout(() => { if(!isAutoFinished) rockets.push(new Rocket(true)); }, 1200);
    </script>
</body>
</html>
