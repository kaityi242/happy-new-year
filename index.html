<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>âœ¨2026 æ–°å¹´å¿«ä¹âœ¨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            margin: 0; 
            background: #000; /* å¤‡ç”¨èƒŒæ™¯è‰² */
            /* ä¼˜åŒ–æ˜Ÿç©ºèƒŒæ™¯ï¼šæ›´è‡ªç„¶çš„å¯†åº¦å’Œåˆ†å¸ƒ */
            background-image: 
                radial-gradient(1px 1px at 20px 30px, #fff, rgba(0,0,0,0)),
                radial-gradient(1.5px 1.5px at 100px 150px, #fff, rgba(0,0,0,0)),
                radial-gradient(1px 1px at 250px 50px, #ddd, rgba(0,0,0,0)),
                radial-gradient(2px 2px at 150px 300px, #fff, rgba(0,0,0,0)),
                radial-gradient(0.8px 0.8px at 400px 200px, #eee, rgba(0,0,0,0)),
                linear-gradient(to bottom, #020107 0%, #050516 100%);
            background-size: 350px 350px, 450px 450px, 380px 380px, 550px 550px, 400px 400px, 100% 100%;
            overflow: hidden; 
            touch-action: none; 
            cursor: crosshair; /* é¼ æ ‡æ ·å¼ä¼˜åŒ– */
        }
        canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh;
        }
        #overlay {
            position: absolute; 
            bottom: 3%; 
            width: 100%; 
            text-align: center;
            color: rgba(255,255,255,0.6); /* æé«˜æ–‡å­—å¯è§åº¦ */
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif; 
            font-size: 14px; /* å¢å¤§å­—å· */
            pointer-events: none; 
            letter-spacing: 3px;
            text-shadow: 0 0 5px rgba(255,255,255,0.3); /* æ–‡å­—å‘å…‰æ•ˆæœ */
            transition: opacity 0.5s ease; /* è¿‡æ¸¡åŠ¨ç”» */
        }
        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 500px) {
            #overlay {
                bottom: 5%;
                font-size: 12px;
                letter-spacing: 2px;
            }
        }
    </style>
</head>
<body>
    <div id="overlay">ç‚¹å±å¹•æ”¾çƒŸèŠ± ğŸ†</div>
    <canvas id="c"></canvas>

    <script>
    // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜DOMå…ƒç´ 
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    // å¼€å¯alphaä»¥æ˜¾ç¤ºCSSèƒŒæ™¯æ˜Ÿæ˜Ÿï¼Œå…³é—­æŠ—é”¯é½¿æå‡æ€§èƒ½
    const ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: true });
    let cw, ch;
    // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨æ•°ç»„æ± å‡å°‘GC
    let particles = [];
    let rockets = [];
    let animationFrameId;
    
    // ã€æ–‡å­—é…ç½®ã€‘- å¯è‡ªå®šä¹‰
    const autoTextList = [
        { text: "2026", pos: 0.30 },
        { text: "è°¢ä¼Šè²", pos: 0.50 },
        { text: "æ–°å¹´å¿«ä¹", pos: 0.72 },
    ];
    let autoTextIdx = 0;

    // åˆå§‹åŒ–ç”»å¸ƒå°ºå¯¸
    function init() {
        // é€‚é…é«˜æ¸…å±
        const dpr = window.devicePixelRatio || 1;
        cw = canvas.width = window.innerWidth * dpr;
        ch = canvas.height = window.innerHeight * dpr;
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        // ç¼©æ”¾ä¸Šä¸‹æ–‡é€‚é…DPR
        ctx.scale(dpr, dpr);
        // é‡ç½®åæ ‡è®¡ç®—åŸºå‡†
        cw = window.innerWidth;
        ch = window.innerHeight;
    }

    // è·å–æ–‡å­—åƒç´ ç‚¹ - æ€§èƒ½ä¼˜åŒ–ç‰ˆ
    function getPixels(text, yPosPercent) {
        const tCanvas = document.createElement('canvas');
        const tCtx = tCanvas.getContext('2d');
        // ç¼©å°ä¸´æ—¶ç”»å¸ƒå°ºå¯¸æå‡æ€§èƒ½ï¼ˆç²’å­å¯†åº¦ä¸å˜ï¼‰
        const scale = 0.5;
        const tempW = cw * scale;
        const tempH = ch * scale;
        tCanvas.width = tempW;
        tCanvas.height = tempH;
        
        // é€‚é…ï¼šæ‰‹æœºç«¯å­—å·ä¼˜åŒ–
        const isMobile = cw < 500;
        const fontSize = text.length > 3 
            ? tempW * (isMobile ? 0.2 : 0.15) 
            : tempW * (isMobile ? 0.28 : 0.22);
        
        tCtx.fillStyle = "white";
        tCtx.font = `bold ${fontSize}px "PingFang SC", "Microsoft YaHei", sans-serif`;
        tCtx.textAlign = "center";
        tCtx.textBaseline = "middle";
        tCtx.fillText(text, tempW/2, tempH * yPosPercent);
        
        const data = tCtx.getImageData(0, 0, tempW, tempH).data;
        const pts = [];
        // ç²’å­å¯†é›†åº¦è®¾ä¸º 4
        const step = 4; 
        for (let y = 0; y < tempH; y += step) {
            for (let x = 0; x < tempW; x += step) {
                if (data[((y * tempW + x) * 4) + 3] > 128) {
                    // è¿˜åŸåˆ°åŸå§‹å°ºå¯¸åæ ‡
                    pts.push({
                        x: x / scale,
                        y: y / scale
                    });
                }
            }
        }
        return pts;
    }

    // ç«ç®­ç±» - ä¼˜åŒ–ç‰©ç†è¿åŠ¨å’Œç»˜åˆ¶
    class Rocket {
        constructor(isAuto = false) {
            this.isAuto = isAuto;
            this.x = cw / 2 + random(-120, 120);
            this.y = ch;
            this.tx = isAuto ? cw / 2 : random(cw * 0.15, cw * 0.85);
            this.ty = isAuto 
                ? ch * autoTextList[autoTextIdx].pos 
                : random(ch * 0.1, ch * 0.55);
            this.hue = random(0, 360);
            this.v = random(12, 16);
            this.done = false;
            // ç«ç®­å°¾ç„°æ•ˆæœ
            this.trail = [];
        }

        update() {
            // è®¡ç®—ç§»åŠ¨æ–¹å‘
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 10) {
                this.explode();
                this.done = true;
            } else {
                // å¹³æ»‘ç§»åŠ¨ - å¢åŠ ç¼“åŠ¨æ•ˆæœ
                const ease = 0.98;
                this.x += (dx/dist) * this.v * ease;
                this.y += (dy/dist) * this.v * ease;
                
                // æ›´æ–°å°¾ç„°
                this.trail.push({x: this.x, y: this.y, alpha: 1});
                if (this.trail.length > 15) this.trail.shift();
            }
        }

        draw() {
            // ç»˜åˆ¶å°¾ç„°
            ctx.save();
            for (let i = 0; i < this.trail.length; i++) {
                const p = this.trail[i];
                const alpha = p.alpha * (i / this.trail.length);
                ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${alpha})`;
                ctx.fillRect(p.x, p.y, 2, 3 + i * 0.2);
            }
            ctx.restore();
            
            // ç»˜åˆ¶ç«ç®­ä¸»ä½“
            ctx.fillStyle = `hsla(${this.hue}, 100%, 75%, 1)`;
            ctx.fillRect(this.x, this.y, 2, 5);
        }

        explode() {
            if (this.isAuto) {
                const item = autoTextList[autoTextIdx];
                const pts = getPixels(item.text, item.pos);
                autoTextIdx++; 
                pts.forEach(p => particles.push(new Particle(this.x, this.y, 45, p)));
                
                // æ–‡å­—çˆ†ç‚¸æ—¶éšè—æç¤ºæ–‡å­—
                if (autoTextIdx === autoTextList.length) {
                    overlay.style.opacity = 0.3;
                }
            } else {
                // ä¿ç•™åŸå§‹çš„å››ç§æ‰‹åŠ¨çƒŸèŠ±æ ·å¼
                const style = Math.floor(random(0, 4));
                const count = 200; 
                const baseHue = random(0, 360);
                const secondHue = (baseHue + 40) % 360; 
                const colors = [baseHue, secondHue, random(0, 360)];

                for(let i=0; i<count; i++) {
                    const h = colors[Math.floor(random(0, colors.length))];
                    if (style === 0) { 
                        particles.push(new Particle(this.x, this.y, h, null, { speed: random(1, 12), gravity: 0.02, friction: 0.98, decay: 0.004 }));
                    } else if (style === 1) { 
                        particles.push(new Particle(this.x, this.y, h, null, { speed: random(2, 15), isStrobe: true, decay: 0.005, gravity: 0.04 }));
                    } else if (style === 2) { 
                        const s = i < 80 ? random(1, 5) : random(8, 16);
                        particles.push(new Particle(this.x, this.y, h, null, { speed: s, friction: 0.93, decay: 0.007 }));
                    } else { 
                        const angle = (i / count) * Math.PI * 20; 
                        const s = random(2, 14);
                        particles.push(new Particle(this.x, this.y, 45, null, { speed: s, vx: Math.cos(angle)*s, vy: Math.sin(angle)*s, decay: 0.006 }));
                    }
                }
            }
        }
    }

    // ç²’å­ç±» - ä¼˜åŒ–ç‰©ç†æ•ˆæœå’Œæ¸²æŸ“
    class Particle {
        constructor(x, y, h, target = null, opt = {}) {
            this.x = x; 
            this.y = y; 
            this.h = h;
            this.target = target;
            this.alpha = 1;
            // æ–‡å­—ç²’å­decayè®¾ä¸º0å®ç°å®šæ ¼
            this.decay = target ? 0 : (opt.decay || random(0.006, 0.012));
            this.isStrobe = opt.isStrobe || false;
            this.gravity = opt.gravity || 0.05;
            this.friction = opt.friction || 0.96;
            
            if (opt.vx !== undefined) {
                this.vx = opt.vx; 
                this.vy = opt.vy;
            } else {
                const angle = Math.random() * Math.PI * 2;
                const speed = opt.speed || (target ? random(2, 6) : random(2, 10));
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
            }
        }

        update() {
            if (this.target) {
                // æ–‡å­—ç²’å­ï¼šå¹³æ»‘é£å‘ç›®æ ‡å¹¶å®šæ ¼
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 1) {
                    this.vx += dx * 0.002;
                    this.vy += dy * 0.002;
                    this.vx *= 0.92; 
                    this.vy *= 0.92;
                    this.x += this.vx;
                    this.y += this.vy;
                } else {
                    // å®šæ ¼åœ¨ç›®æ ‡ä½ç½®
                    this.x = this.target.x;
                    this.y = this.target.y;
                    this.vx = 0; 
                    this.vy = 0;
                }
            } else {
                // æ™®é€šç²’å­ï¼šç‰©ç†è¿åŠ¨
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.x += this.vx;
                this.y += this.vy;
            }
            
            // é€æ˜åº¦è¡°å‡ï¼ˆä»…æ™®é€šç²’å­ï¼‰
            this.alpha -= this.decay;
        }

        draw() {
            if (this.alpha <= 0) return;
            
            // é¢‘é—ªæ•ˆæœä¼˜åŒ–
            if (this.isStrobe && Math.random() > 0.6) return; 

            // ç²’å­å°ºå¯¸ä¼˜åŒ–
            const size = this.target ? 1.5 : random(1.5, 3);
            const lightness = this.isStrobe ? 90 : 75;
            
            // ç»˜åˆ¶ç²’å­ - åœ†å½¢æ›´ç¾è§‚
            ctx.save();
            ctx.fillStyle = `hsla(${this.h}, 100%, ${lightness}%, ${this.alpha})`;
            ctx.beginPath();
            ctx.arc(this.x, this.y, size/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // ä¸»å¾ªç¯ - æ€§èƒ½ä¼˜åŒ–
    function loop() {
        // åŠé€æ˜æ¸…å±ï¼Œä¿ç•™æ‹–å½±æ•ˆæœï¼ŒåŒæ—¶è®©æ˜Ÿç©ºé€å‡º
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.15)'; 
        ctx.fillRect(0, 0, cw, ch);
        ctx.globalCompositeOperation = 'lighter';

        // æ›´æ–°å’Œç»˜åˆ¶ç«ç®­
        for (let i = rockets.length - 1; i >= 0; i--) {
            const r = rockets[i];
            r.update(); 
            r.draw();
            if (r.done) rockets.splice(i, 1);
        }

        // æ›´æ–°å’Œç»˜åˆ¶ç²’å­ï¼ˆåå‘éå†é¿å…ç´¢å¼•é—®é¢˜ï¼‰
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.update(); 
            p.draw();
            if (p.alpha <= 0) particles.splice(i, 1);
        }
        
        // é˜²æ­¢å†…å­˜æ³„æ¼
        if (particles.length > 10000) {
            particles = particles.slice(-8000);
        }

        animationFrameId = requestAnimationFrame(loop);
    }

    // å·¥å…·å‡½æ•°
    function random(min, max) { 
        return Math.random() * (max - min) + min; 
    }

    // æ‰‹åŠ¨å‘å°„çƒŸèŠ±
    function manualLaunch() {
        rockets.push(new Rocket(false));
        // éšæœºåŒå‘å°„å‡»æ•ˆæœ
        if(Math.random() > 0.7) {
            setTimeout(() => rockets.push(new Rocket(false)), 200);
        }
        // ç‚¹å‡»æ—¶é«˜äº®æç¤ºæ–‡å­—
        overlay.style.opacity = 1;
        setTimeout(() => {
            if (autoTextIdx === autoTextList.length) {
                overlay.style.opacity = 0.6;
            }
        }, 1000);
    }

    // è‡ªåŠ¨å‘å°„åºåˆ—
    function startAutoSequence() {
        if (autoTextIdx < autoTextList.length) {
            rockets.push(new Rocket(true));
            setTimeout(startAutoSequence, 3800);
        }
    }

    // äº‹ä»¶ç›‘å¬
    window.addEventListener('touchstart', e => { 
        e.preventDefault(); 
        manualLaunch(); 
    }, { passive: false });
    
    window.addEventListener('mousedown', manualLaunch);
    window.addEventListener('resize', () => {
        // é˜²æŠ–å¤„ç†
        clearTimeout(window.resizeTimer);
        window.resizeTimer = setTimeout(init, 100);
    });
    
    // é¡µé¢å¸è½½æ—¶æ¸…ç†åŠ¨ç”»
    window.addEventListener('beforeunload', () => {
        cancelAnimationFrame(animationFrameId);
    });

    // åˆå§‹åŒ–
    init();
    loop();
    // 1ç§’åå¼€å¯è‡ªåŠ¨åºåˆ—
    setTimeout(startAutoSequence, 1000);
    </script>
</body>
</html>
