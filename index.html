<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>✨新年快乐✨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #overlay {
            position: absolute; bottom: 3%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.3); font-family: sans-serif; font-size: 12px;
            pointer-events: none; letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="overlay">点屏幕放烟花>diand
    <canvas id="c"></canvas>

    <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    let cw, ch, particles = [], rockets = [];
    
    // 自动播放文字内容及纵向位置(0.2表示屏幕上方20%处)
    const autoTextList = [
        { text: "2026", pos: 0.15 },
        { text: "谢伊菲", pos: 0.35 },
        { text: "新年快乐", pos: 0.55 },
        { text: "万事如意", pos: 0.80 }
    ];
    let autoTextIdx = 0;

    function init() {
        cw = canvas.width = window.innerWidth;
        ch = canvas.height = window.innerHeight;
    }

    // 获取特定位置的文字像素
    function getPixels(text, yPosPercent) {
        const tCanvas = document.createElement('canvas');
        const tCtx = tCanvas.getContext('2d');
        tCanvas.width = cw; tCanvas.height = ch;
        tCtx.fillStyle = "white";
        // 加大字体：手机端更清晰
        const fontSize = text.length > 3 ? cw * 0.18 : cw * 0.25;
        tCtx.font = `bold ${fontSize}px sans-serif`;
        tCtx.textAlign = "center";
        tCtx.fillText(text, cw/2, ch * yPosPercent);
        
        const data = tCtx.getImageData(0, 0, cw, ch).data;
        const pts = [];
        for (let y = 0; y < ch; y += 7) {
            for (let x = 0; x < cw; x += 7) {
                if (data[((y * cw + x) * 4) + 3] > 128) pts.push({x, y});
            }
        }
        return pts;
    }

    // 烟花弹类（从下往上飞）
    class Rocket {
        constructor(tx, ty, isAuto = false) {
            this.x = cw / 2 + (Math.random() - 0.5) * 100; // 从底部中间随机偏移
            this.y = ch;
            this.tx = tx;
            this.ty = ty;
            this.isAuto = isAuto;
            this.hue = isAuto ? 45 : Math.random() * 360;
            this.v = random(12, 18); // 初始上升速度
            this.done = false;
        }
        update() {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 15) {
                this.explode();
                this.done = true;
            } else {
                this.x += (dx/dist) * this.v;
                this.y += (dy/dist) * this.v;
                this.v *= 0.98; // 稍微减速更有真实感
            }
        }
        draw() {
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
            ctx.fillRect(this.x, this.y, 3, 3); // 弹头
        }
        explode() {
            if (this.isAuto) {
                const item = autoTextList[autoTextIdx];
                const pts = getPixels(item.text, item.pos);
                autoTextIdx = (autoTextIdx + 1) % autoTextList.length;
                pts.forEach(p => particles.push(new Particle(this.x, this.y, 45, p)));
            } else {
                const count = 100;
                for(let i=0; i<count; i++) particles.push(new Particle(this.x, this.y, this.hue));
            }
        }
    }

    class Particle {
        constructor(x, y, h, target = null) {
            this.x = x; this.y = y; this.h = h;
            this.target = target;
            this.alpha = 1;
            // 自动文字粒子消散极慢(0.003)，手动粒子常规(0.01)
            this.decay = target ? 0.003 : random(0.01, 0.02);
            const angle = Math.random() * Math.PI * 2;
            const speed = target ? random(-2, 2) : random(2, 10);
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
        }
        update() {
            if (this.target) {
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                this.vx += dx * 0.003;
                this.vy += dy * 0.003;
                this.vx *= 0.93; this.vy *= 0.93;
            } else {
                this.vy += 0.08;
                this.vx *= 0.96; this.vy *= 0.96;
            }
            this.x += this.vx; this.y += this.vy;
            this.alpha -= this.decay;
        }
        draw() {
            const s = this.target ? 2 : 1.5;
            ctx.fillStyle = `hsla(${this.h}, 100%, 70%, ${this.alpha})`;
            ctx.fillRect(this.x, this.y, s, s);
        }
    }

    function loop() {
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0, 0, cw, ch);
        ctx.globalCompositeOperation = 'lighter';

        rockets.forEach((r, i) => {
            r.update(); r.draw();
            if (r.done) rockets.splice(i, 1);
        });

        particles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.alpha <= 0) particles.splice(i, 1);
        });
        requestAnimationFrame(loop);
    }

    function random(min, max) { return Math.random() * (max - min) + min; }

    window.addEventListener('touchstart', e => {
        e.preventDefault();
        rockets.push(new Rocket(e.touches[0].clientX, e.touches[0].clientY));
    }, { passive: false });
    window.addEventListener('mousedown', e => rockets.push(new Rocket(e.clientX, e.clientY)));
    window.addEventListener('resize', init);

    init();
    loop();

    // 自动播放：每 4.5 秒发射一个文字烟火
    setInterval(() => {
        const item = autoTextList[autoTextIdx];
        rockets.push(new Rocket(cw/2, ch * item.pos, true));
    }, 4500);
    
    // 首发延迟
    setTimeout(() => rockets.push(new Rocket(cw/2, ch * autoTextList[0].pos, true)), 1000);
    </script>
</body>
</html>
