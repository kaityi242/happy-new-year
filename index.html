<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>✨ 2026 璀璨之约 - 致谢伊菲 ✨</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        #overlay {
            position: absolute; bottom: 3%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.3); font-family: sans-serif; font-size: 12px;
            pointer-events: none; letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div id="overlay">点击屏幕发射烟火 · 见证浪漫时刻</div>
    <canvas id="c"></canvas>

    <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });
    let cw, ch, particles = [], rockets = [];
    
    // 【配置：自动播放文字】
    const autoTextList = [
        { text: "2026", pos: 0.15 },
        { text: "谢伊菲", pos: 0.35 },
        { text: "新年快乐", pos: 0.55 },
        { text: "万事如意", pos: 0.75 }
    ];
    let autoTextIdx = 0;

    function init() {
        cw = canvas.width = window.innerWidth;
        ch = canvas.height = window.innerHeight;
    }

    // 预处理文字像素
    function getPixels(text, yPosPercent) {
        const tCanvas = document.createElement('canvas');
        const tCtx = tCanvas.getContext('2d');
        tCanvas.width = cw; tCanvas.height = ch;
        tCtx.fillStyle = "white";
        const fontSize = text.length > 3 ? cw * 0.18 : cw * 0.26;
        tCtx.font = `bold ${fontSize}px sans-serif`;
        tCtx.textAlign = "center";
        tCtx.fillText(text, cw/2, ch * yPosPercent);
        
        const data = tCtx.getImageData(0, 0, cw, ch).data;
        const pts = [];
        for (let y = 0; y < ch; y += 6) { // 采样间距，越小越密
            for (let x = 0; x < cw; x += 6) {
                if (data[((y * cw + x) * 4) + 3] > 128) pts.push({x, y});
            }
        }
        return pts;
    }

    // 【类：烟花弹】从底部发射升空
    class Rocket {
        constructor(isAuto = false) {
            this.isAuto = isAuto;
            // 发射起点：底部中心随机偏移
            this.x = cw / 2 + random(-100, 100);
            this.y = ch;
            
            if (isAuto) {
                // 自动烟花：目标是配置好的纵向位置
                this.tx = cw / 2;
                this.ty = ch * autoTextList[autoTextIdx].pos;
            } else {
                // 手动烟花：目标位置随机（全屏高度 10% - 60% 之间爆炸）
                this.tx = random(cw * 0.1, cw * 0.9);
                this.ty = random(ch * 0.1, ch * 0.6);
            }
            
            this.hue = isAuto ? 45 : random(0, 360);
            this.v = random(10, 15); // 上升速度
            this.done = false;
        }

        update() {
            const dx = this.tx - this.x;
            const dy = this.ty - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 10) {
                this.explode();
                this.done = true;
            } else {
                this.x += (dx/dist) * this.v;
                this.y += (dy/dist) * this.v;
            }
        }

        draw() {
            // 绘制上升尾迹
            ctx.fillStyle = `hsla(${this.hue}, 100%, 70%, 1)`;
            ctx.fillRect(this.x, this.y, 2, 4);
        }

        explode() {
            if (this.isAuto) {
                const item = autoTextList[autoTextIdx];
                const pts = getPixels(item.text, item.pos);
                autoTextIdx = (autoTextIdx + 1) % autoTextList.length;
                pts.forEach(p => particles.push(new Particle(this.x, this.y, 45, p)));
            } else {
                // 【手动：随机三种华丽样式】
                const style = Math.floor(random(0, 3));
                const count = 150; // 手动烟花数量增加
                const hue = this.hue;

                for(let i=0; i<count; i++) {
                    if (style === 0) { // 样式1：长垂柳（带重力感）
                        particles.push(new Particle(this.x, this.y, hue, null, { gravity: 0.03, friction: 0.98, decay: 0.006 }));
                    } else if (style === 1) { // 样式2：星光闪烁
                        particles.push(new Particle(this.x, this.y, hue, null, { speed: random(2, 12), isStrobe: true, decay: 0.008 }));
                    } else { // 样式3：超大爆发
                        particles.push(new Particle(this.x, this.y, hue, null, { speed: random(5, 18), friction: 0.92, decay: 0.01 }));
                    }
                }
            }
        }
    }

    // 【类：粒子】烟花炸开后的点
    class Particle {
        constructor(x, y, h, target = null, opt = {}) {
            this.x = x; this.y = y; this.h = h;
            this.target = target;
            this.alpha = 1;
            
            // 【优化①：弥留时间】
            // target存在时（文字），衰减极慢，确保四个词能同屏
            this.decay = target ? 0.0015 : (opt.decay || 0.01); 
            
            this.isStrobe = opt.isStrobe || false; // 是否闪烁
            this.gravity = opt.gravity || 0.06;
            this.friction = opt.friction || 0.95;
            
            const angle = Math.random() * Math.PI * 2;
            const speed = opt.speed || (target ? random(-1, 1) : random(2, 8));
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
        }

        update() {
            if (this.target) {
                // 文字汇聚逻辑
                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                this.vx += dx * 0.002;
                this.vy += dy * 0.002;
                this.vx *= 0.92; this.vy *= 0.92;
            } else {
                // 普通爆炸物理逻辑
                this.vy += this.gravity;
                this.vx *= this.friction;
                this.vy *= this.friction;
            }
            this.x += this.vx;
            this.y += this.vy;
            this.alpha -= this.decay;
        }

        draw() {
            if (this.alpha <= 0) return;
            // 【优化⑤：闪烁动画】
            if (this.isStrobe && Math.random() > 0.7) return; 

            // 【优化④：增大粒子尺寸】文字粒子设为2.5，手动设为2
            const s = this.target ? 2.5 : 2;
            ctx.fillStyle = `hsla(${this.h}, 100%, 75%, ${this.alpha})`;
            ctx.fillRect(this.x, this.y, s, s);
        }
    }

    function loop() {
        // 增强背景拖尾感
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0,0,0,0.15)'; 
        ctx.fillRect(0, 0, cw, ch);
        ctx.globalCompositeOperation = 'lighter';

        rockets.forEach((r, i) => {
            r.update(); r.draw();
            if (r.done) rockets.splice(i, 1);
        });

        particles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.alpha <= 0) particles.splice(i, 1);
        });
        requestAnimationFrame(loop);
    }

    function random(min, max) { return Math.random() * (max - min) + min; }

    // 【优化③：手动发射逻辑】点击屏幕，从底部射向随机点
    function manualLaunch() {
        rockets.push(new Rocket(false));
    }

    window.addEventListener('touchstart', e => { e.preventDefault(); manualLaunch(); }, { passive: false });
    window.addEventListener('mousedown', manualLaunch);
    window.addEventListener('resize', init);

    init();
    loop();

    // 【优化①：自动播放频率】
    // 缩短发射间隔，配合极慢的消散速度，实现四个词“全家福”展现
    setInterval(() => {
        rockets.push(new Rocket(true));
    }, 3500); 
    
    // 首发
    setTimeout(() => rockets.push(new Rocket(true)), 1000);
    </script>
</body>
</html>
